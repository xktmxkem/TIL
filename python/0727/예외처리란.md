# 에러 & 예외 처리

* 에러(Error)
* 예외처리(Exception Handling)

--------

![0727](../python_asset/0727.png)

> #  에러 
>
> > ### 1.1 문법 에러(Suntax Error)
> >
> > * 함수는 코드 내부에 스코프(scope)를 생성한다.
> >
> > *  함수로 생성된 공간은 `지역 스코프(local scope)`라고 불리며, 그 외의 공간인 `전역 스코프(global scope)`와 구분된다.
> >
> >   * **전역 스코프(`global scope`)**: 코드 어디에서든 참조할 수 있는 공간
> >   * **지역 스코프(`local scope`)**: 함수가 만든 스코프로 함수 내부에서만 참조할 수 있는 공간
> >
> >   - **전역 변수(`global variable`)**: 전역 스코프에 정의된 변수
> >   - **지역 변수(`local variable`)**: 로컬 스코프에 정의된 변수
> >
> > >**1.1 변수의 수명주기 **
> > >
> > >* 변수의 이름은 각자의 `수명주기(lifecycle)`가 있습니다.
> > >
> > >  * **빌트인 스코프`(built-in scope)`**: 파이썬이 실행된 이후부터 영원히 유지
> > >  * **전역 스코프`(global scope)`**: 모듈이 호출된 시점 이후 혹은 이름 선언된 이후부터 인터프리터가 끝날 때 까지 유지
> > >
> > >  - **지역(함수) 스코프`(local scope)`**: 함수가 호출될 때 생성되고, 함수가 종료될 때까지 유지 (함수 내에서 처리되지 않는 예외를 일으킬 때 삭제됨)
> > >
> > >**1.2 이름 검색(resolution) 규칙**
> > >
> > >* 파이썬에서 사용되는 이름(식별자)들은 이름공간(namespace)에 저장되어 있다.
> > >
> > >  아래와 같은 순서로 이름을 찾아나가며, `LEGB Rule` 이라고 부른다. 
> > >
> > >  * `L`ocal scope: 함수
> > >
> > >
> > >  * `E`nclosed scope: 특정 함수의 상위 함수 
> > >
> > >
> > >  * `G`lobal scope: 함수 밖의 변수 혹은 import된 모듈
> > >
> > >
> > >  * `B`uilt-in scope: 파이썬안에 내장되어 있는 함수 또는 속성
> > >
> > >* 기본적으로 함수에서 선언된 변수는 Local scope에 생성되며, 함수 종료 시 사라진다.
> > >
> > >* 해당 스코프에 변수가 없는 경우 LEGB rule에 의해 이름을 검색한다.
> > >
> > >  - 변수에 접근은 가능하지만, 해당 변수를 수정할 수는 없다.
> > >  - 값을 할당하는 경우 해당 스코프의 이름공간에 새롭게 생성된다.
> > >  - **단, 함수 내에서 필요한 상위 스코프 변수는 인자로 넘겨서 활용한다.** (클로저 제외)
> > >
> > >* 상위 스코프에 있는 변수를 수정하고 싶다면 global, nonlocal 키워드를 활용 한다.
> > >
> > >  - 단, 코드가 복잡해지면서 변수의 변경을 추적하기 어렵고, 예기치 못한 오류가 발생한다.
> >
> > ### 2. 재귀 함수(recursive function)
> >
> > * 재귀 함수는 함수 내부에서 자기 자신을 호출 하는 함수를 뜻한다.
> >
> >   알고리즘을 설계 및 구현에서 유용하게 활용된다.
> >
> > >**2.1 팩토리얼 계산**
> > >
> > >* 반복문
> > >
> > >```python
> > >def fact(num):
> > >    result = 1
> > >    for i in range(1, num):
> > >        result *= i
> > >    return result
> > >```
> > >
> > >* 재귀문
> > >
> > >```python
> > >def factorial(num):
> > >    if num < 2:
> > >        return 1
> > >    return num * factorial(num - 1)
> > >```
> > >
> > >- 두 코드 모두 원리는 같다.
> > >
> > >1. 반복문 코드
> > >   - n이 1보다 큰 경우 반복문을 돌며, n은 1씩 감소한다.
> > >   - 마지막에 n이 1이면 더 이상 반복문을 돌지 않는다.
> > >
> > >1. 재귀 함수 코드
> > >   - 재귀 함수를 호출하며, n은 1씩 감소한다.
> > >   - 마지막에 n이 1이면 더 이상 추가 함수를 호출하지 않는다.
> > >
> > >- 재귀함수는 기본적으로 같은 문제이지만 점점 범위가 줄어드는 문제를 풀게 된다.
> > >- 재귀함수를 작성시에는 반드시, `base case`가 존재 하여야 한다.
> > >- `base case`는 점점 범위가 줄어들어 반복되지 않는 최종적으로 도달하는 곳을 의미한다.
> > >- 재귀를 이용한 팩토리얼 계산에서의 base case는 **n이 1일때, 함수가 아닌 정수 반환하는 것**입이다.
> > >
> > >- 자기 자신을 호출하는 재귀함수는 알고리즘 구현시 많이 사용된다.
> > >- 코드가 더 직관적이고 이해하기 쉬운 경우가 있다.
> > >- 팩토리얼 재귀함수를 [Python Tutor](https://goo.gl/k1hQYz)에서 확인해보면, 함수가 호출될 때마다 메모리 공간에 쌓이는 것을 볼 수 있다.
> > >- 이 경우, 메모리 스택이 넘치거나(Stack overflow) 프로그램 실행 속도가 늘어지는 단점이 생긴다.
> > >- 파이썬에서는 이를 방지하기 위해 1,000번이 넘어가게 되면 더이상 함수를 호출하지 않고, 종료된다. (최대 재귀 깊이)
> > >
> > >**2.2 피보나치 계산**
> > >
> > >* 반복문
> > >
> > >```python
> > >def fib(n):
> > >    if n < 2:
> > >        return n
> > >    else:
> > >        return fib(n-1) + fib(n-2)
> > >```
> > >
> > >* 재귀문
> > >
> > >```python
> > >def fib_loop(n):
> > >    fib_list=[0, 1]
> > >    for i in range(2,n+1):
> > >        fib_list += [fib_list[i-1] + fib_list[i-2]]
> > >    return fib_list[-1]
> > >```
> > >
> > >**2.3 반복문과 재귀문 차이**
> > >
> > >* 반복문 : 일반적으로 계산 속도가 재귀보다 빠르다
> > >* 재귀문 : 변수 사용을 줄일 수 있다.
> > >
> > >

---

### Reference

https://wikidocs.net/66

